#include <stdio.h>
#include <stdlib.h>
#include<time.h>

int main() {
	srand(time(0));
	int a=rand()%101;
	int b=0;
	int cnt=0;
	printf("玩家您好，在1-100中我选择了一个整数，请您猜一猜。");
	scanf("%d",&b);
	/*
	在这里，我感觉对于计数器的处理，更好的办法是cnt = 1
	然后在循环的最后cnt++ ,
	这样在跳出循环以后，就不用做额外的cnt++ 的处理了
	你可以实际跑一下程序看看
	你可以推理下：
	如果cnt 刚开始等于1，你第一次输入的数字就猜对了，那循环就不执行了
	直接输出第1次猜对了。
	如果没有猜对，那重新输入一次数据，计数器就加1，直到猜对为止
	那就是哪一次猜对了，计数器就刚好是那个数字，就不用在while
	循环外面在多加一句cnt++
	*/
	while(a!=b){
		cnt++;
		/*
		这地方的问题，就是更好的方法是使用if else 方法，而不是写两个if
		这种写法容易出现程序逻辑判断失误。
		另外一个问题：
		a 是常量，刚开始就赋值以后不变的量
		那更好的写法是写成  b>a 或者 b<a 
		这样程序可读性才好，你是拿一个变化的数字和不变的数字去比较，
		但好的程序风格，有些时候为了避免出现bug，也有不变的写在前面，变化的写在后面
		例如：
		1 == a  是判断a 是否等于 1 ，这样写，如果你不小心写错了，写成 1 = a 
		那编译会报错，程序编译不过去，
		但如果你写成  a = 1，这个时候编译不会报错，但程序出bug了，不是判断a是否等于1
		而是将1 赋值给 a ，这也是为了避免程序出现bug常用的一种书写方法。
		*/
		if(a>b){
			printf("猜小了！"); 
		}
		if(a<b){
			printf("猜大了！"); 
		}
		// 这地方的printf 最好加上\n 要回车
		
		printf("请再猜一次");
		scanf("%d",&b); 
		
	}
	/*
	这段程序有两个问题：
	1、 a=b 是经常容易出现错误的一种场景，在这里是做判断，准确的做法是  a == b 
	   a=b  是赋值操作，把b的值赋值给a，返回应该都是0 ，然后会陷入死循环
	2、 第二个问题是  前面的判断是 a != b ,如果前面的循环停止了，那一定是
	出现了一种情况 ， a == b 了，那下面的这个循环就是多余的。
	直接把后面的程序写出来就行，而且不用break，你现在的程序之所以没有出现死循环，
	就是因为多些了一个break。
	*/
	while(a=b){
		cnt++;
		printf("恭喜您猜对了,答案就是%d,您用了%d次猜对。",a,cnt); 
		break;
	} 

	return 0;
}
